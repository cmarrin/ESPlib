<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Shell</title>
    <link rel='stylesheet' href='https://unpkg.com/xterminal/dist/xterminal.css'>
    
    <style>
        body {
            background-color: var(--xt-bg);
            --xt-fg: #0b0;
        }
        
        #app {
            height: 96vh;
            border: 2px solid gray;
            border-radius:10px;
            padding:5px;
            margin:5px;
        }
        
        .error {
            color: rgb(248, 88, 88);
        }
        .prompt1 {
            color: rgb(88, 248, 248);
        }
        .prompt2 {
            color: rgb(88, 248, 88);
        }

        .ansi-black-fg { color: #000; }             /* 30 */
        .ansi-red-fg { color: #b00; }               /* 31 */
        .ansi-green-fg { color: #0b0; }             /* 32 */
        .ansi-yellow-fg { color: #bb0; }            /* 33 */
        .ansi-blue-fg { color: #00b; }              /* 34 */
        .ansi-magenta-fg { color: #b0b; }           /* 35 */
        .ansi-cyan-fg { color: #0bb; }              /* 36 */
        .ansi-white-fg { color: #fff; }             /* 37 */

        .ansi-bright-black-fg { color: #555; }      /* 90 */
        .ansi-bright-red-fg { color: #f55; }        /* 91 */
        .ansi-bright-green-fg { color: #0f0; }      /* 92 */
        .ansi-bright-yellow-fg { color: #ff5; }     /* 93 */
        .ansi-bright-blue-fg { color: #55f }        /* 94 */
        .ansi-bright-magenta-fg { color: #f5f }     /* 95 */
        .ansi-bright-cyan-fg { color: #5ff }        /* 96 */
        .ansi-bright-white-fg { color: #fff }       /* 97 */
</style>
</head>

<body>
    <div id="app"></div>

    <script src='https://unpkg.com/xterminal/dist/xterminal.umd.js'></script>

    <script>
        // We want to get the number of chars that will fit on a line of the shell so
        // we can send that to the server so the Lua commands can format a line of
        // text. We need to compute the width of a character. Since we're using a
        // fixed pitch font every character is the same width. So we just need a
        // constant to convert from the font size to character width and then divide
        // the pixel width of the shell by that. For the current font being used 
        // (whatever that is) the constant below works.
        //
        // Constant for converting from font size to character width
        const CharWidthConstant = 1.73;
        
        // Computing the characters per line:
        //      CPL = width * CharWidthConstant / fontSize;
        
        window.onload = () => createTerminal('#app');
        
        let cpl = 0;
        
        const shell = document.getElementById('app');
        const resizeObserver = new ResizeObserver((entries) => {
            for (const entry of entries) {
                const style = window.getComputedStyle(shell, null).getPropertyValue('font-size');
                const fontSize = parseFloat(window.getComputedStyle(shell, null).getPropertyValue('font-size'));
                const width = entry.contentRect.width;
                cpl = Math.trunc(width * CharWidthConstant / fontSize);
            }
        });
        resizeObserver.observe(shell);
        
        function createTerminal(target)
        {
            const term = new XTerminal({ target });
            
            let status = " ";

            const state = { 
                username: "user",
                hostname: "web"
            };

            // input evaluator
            const shell = createShell();

            // print prompt and get ready for user input
            function promptUser() {
                term.write(`<span class="prompt1">[${state.username}@${state.hostname}]</span>\n`);
                term.write(`<span class="prompt2">$ </span>`);
                term.resume();
                term.focus();
            }
            
            function handleExecComplete()
            {
                if (status == " ") {
                    promptUser();
                } else {
                    fetch(`/shell?id=${status}`)
                        .then(response => response.text())
                        .then(data => writeResponse(data))
                        .catch(error => console.error('Error fetching more data:', error))
                        .finally(handleExecComplete)
                }
            }

            const FirstNormalColor = 30;
            const NormalColors = [
                "ansi-black-fg",
                "ansi-red-fg",
                "ansi-green-fg",  
                "ansi-yellow-fg", 
                "ansi-blue-fg",   
                "ansi-magenta-fg",
                "ansi-cyan-fg",   
                "ansi-white-fg"
            ];
            
            const FirstBrightColor = 90;
            const BrightColors = [
                "ansi-bright-black-fg",
                "ansi-bright-red-fg",
                "ansi-bright-green-fg",  
                "ansi-bright-yellow-fg", 
                "ansi-bright-blue-fg",   
                "ansi-bright-magenta-fg",
                "ansi-bright-cyan-fg",   
                "ansi-bright-white-fg"
            ];
            
            function stringHasEscapes(s)
            {
                return s.indexOf("\x1b") != -1;
            }
            
            function addColorToString(s)
            {
                // We currently handle simple color escapes (e.g., 0x1b[33m for yellow)
                // Split the string by ansi escape char (ESC/0x1b)
                const parts = s.split("\x1b");
                let newString = "";
                
                // Construct a new string with spans inserted to set the style for the
                // desired color
                let first = true;
                for (const it of parts) {
                    // first string just goes in with a span
                    if (first) {
                        newString = it;
                        first = false;
                        continue;
                    }
                    
                    // Ignore the entire string if the escape sequence is wrong
                    let colorStyle = "";
                    let endOfEscape = -1;
                    
                    if (it.charAt(0) == "[") {
                        endOfEscape = it.indexOf("m");
                        const numString = it.slice(1, endOfEscape);
                        const colorNum = parseInt(numString);
                        if (!isNaN(colorNum)) {
                            if (colorNum >= FirstNormalColor && colorNum <= (FirstNormalColor + 7)) {
                                colorStyle = NormalColors[colorNum - FirstNormalColor];
                            } else if (colorNum >= FirstBrightColor && colorNum <= (FirstBrightColor + 7)) {
                                colorStyle = BrightColors[colorNum - FirstBrightColor];
                            } else if (colorNum == 0) {
                                colorStyle = "default";
                            }
                        }
                    }
                    
                    if (colorStyle.length == 0) {
                        // Bad escape sequence, ignore this string
                        continue;
                    }
                    
                    if (colorStyle == "default") {
                        // Default color, no span needed
                        newString += it.slice(endOfEscape + 1);
                    } else {
                        // Add the span to the string
                        newString += `<span class='${colorStyle}'>${it.slice(endOfEscape + 1)}</span>`;
                    }
                }
                return newString;
            }
            
            function writeResponse(response)
            {
                // response is plain text, but with a prefix char that has a
                // value of 0x20 to 0x7f. A value of 0x20 means this is the
                // last response for this command. Otherwise it is the id of
                // the Lua command being executed which needs to be sent in
                // the request for more data.
                status = response[0];
                response = response.substring(1);
                
                const hasColor = stringHasEscapes(response);
                if (hasColor) {
                    response = addColorToString(response);
                }
                
                // If the string ends in a newline it means we have 
                // whole lines so we output them all with writeln.
                // Otherwise we output the last line with write.
                const wholeLine = response.slice(-1) == "\n"
                
                // Get rid of the last newline so we don't accidentally
                // print a blank line
                if (wholeLine) {
                    response = response.slice(0, -1);
                }

                // Split the string on sep
                const strings = response.split("\n");
                let lastString = "";
                if (!wholeLine) {
                    lastString = strings.pop();
                }
                
                // Print each string
                for (const it of strings) {
                    if (hasColor) {
                        term.writeln(it);
                    } else {
                        term.writelnSafe(it);
                    }
                }
                
                // Print the last string if any
                if (!wholeLine) {
                     if (hasColor) {
                        term.write(lastString);
                    } else {
                        term.writeSafe(lastString);
                    }
                }
            }
        
            // user input handler
            term.on("data", async input => {

                // deactivate until the execution is done
                term.pause();

                // execute command
                await shell.execute(term, input)
                    .then(res => res && writeResponse(res))
                    .catch(err => {
                        if (err) {
                            // sanitize error to prevent xss attacks
                            // error may contain user input or HTML strings (like script tags)
                            term.writeln(`<span class="error">${XTerminal.escapeHTML(err)}</span>\n`)
                        }
                    })
                    .finally(handleExecComplete);
            });

            // greeting message
            term.writeln("Welcome to XTerminal (v" + XTerminal.version + ")");
            term.writeln("Type `help` for available commands\n");
            
            // kickstart
            promptUser();

            // remember to free resources
            window.addEventListener('unload', () => term.dispose());
        }

        async function processCommand(command) {
            return fetch(`/shell?cmd=${command}&cpl=${cpl}`)
                .then(response => response.text())
                .then(data => {
                    return data;
                })
                .catch(error => console.error('Error processing command:', error));
        }
        
       async function processCommandMoreData(id) {
            return fetch(`/shell?id=${id}`)
                .then(response => response.text())
                .then(data => {
                    return data;
                })
                .catch(error => console.error('Error processing command:', error));
        }

        function createShell() {

            // Help
            const manual = `XTerminal : version ${XTerminal.version}

        Type 'help' to see this list
          
        Commands:
          <cmd> <args>    execute lua command
          clear           clear the terminal screen
          help            display this list
        `;


            // evaluate user input from the terminal
            // -> can be shared among several terminal objects
            function execute(term, command = '') {
                let args = command.split(' ');
                let cmd = args.shift();

                // Help menu
                if (cmd == 'help') {
                    return Promise.resolve(manual);
                } 
                // Clear the terminal
                else if (cmd == 'clear') {
                    term.clear();
                    return Promise.resolve(null);
                } 
                // Send command to server
                else {
                    return new Promise(async (res, rej) => {
                        let output, error;
                        term.write('<span class="spinner"></span> Processing...');
                        await processCommand(command)
                            .then(val => output = val)
                            .catch(err => error = ':( Not found!')
                            .finally(() => term.clearLast());
                        if (error) {
                            rej(error);
                        } else {
                            res(output);
                        }
                    });
                }
            }

            return { execute };
        }
    </script>
</body>
</html>
